# CiRA Block Runtime

A dynamic block-based execution runtime for deploying CiRA pipelines to embedded devices without recompilation.

## Overview

The CiRA Block Runtime enables dynamic loading and execution of pipeline blocks on target hardware (Jetson Nano, Arduino UNO Q, etc.). This allows updating pipelines by simply changing the manifest file, without recompiling C++ code.

## Architecture

```
Pipeline Builder (Dev) → block_manifest.json → Target Device (Runtime)
                                                      ↓
                                              Load blocks (.so)
                                                      ↓
                                              Execute pipeline
```

## Features

- **Dynamic Block Loading**: Load blocks as shared libraries (`.so` files)
- **Manifest-Driven**: Configure pipelines via JSON without code changes
- **Multi-Platform**: Supports Jetson Nano, Arduino UNO Q, and more
- **Real-Time Execution**: Configurable execution rate (Hz)
- **Graceful Shutdown**: Handles SIGINT/SIGTERM signals
- **Statistics Tracking**: Execution time, error count, iteration count

## Building

### Prerequisites

- CMake 3.10+
- C++17 compiler (g++, clang++)
- Linux (for Jetson Nano / Arduino UNO Q)

### Compile

```bash
mkdir build
cd build
cmake ..
make -j$(nproc)
```

### Install

```bash
sudo make install
```

This installs:
- `/usr/local/bin/cira-block-runtime` - Runtime executable
- `/usr/local/include/cira-block-runtime/` - Headers for block development

## Usage

### Basic Usage

```bash
cira-block-runtime /path/to/block_manifest.json
```

### Options

```bash
cira-block-runtime <manifest.json> [options]

Options:
  --block-path <path>    Set custom block library path
                         (default: /usr/local/lib/cira/blocks/)
  --iterations <n>       Run for N iterations then exit (default: infinite)
  --rate <hz>            Execution rate in Hz (default: 10)
  --help                 Show help message
```

### Example

```bash
# Run pipeline at 100 Hz
cira-block-runtime manifest.json --rate 100

# Run for 1000 iterations then exit
cira-block-runtime manifest.json --iterations 1000

# Use custom block library path
cira-block-runtime manifest.json --block-path /opt/cira/blocks/
```

## Block Manifest Format

The block manifest is a JSON file generated by Pipeline Builder:

```json
{
  "format_version": "1.0",
  "pipeline_name": "gesture_recognition",
  "target_platform": "jetson_nano",
  "blocks": [
    {
      "id": "adxl345-sensor",
      "version": "1.0.0",
      "type": "i2c-device",
      "dependencies": ["i2c-tools"]
    },
    {
      "id": "timesnet",
      "version": "1.2.0",
      "type": "onnx-runtime",
      "dependencies": ["onnx-runtime-1.16.0"]
    }
  ],
  "pipeline": {
    "nodes": [...],
    "connections": [...]
  }
}
```

## Block Development

Blocks are shared libraries (`.so`) that implement the `IBlock` interface.

### Block Interface

```cpp
#include <cira-block-runtime/block_interface.hpp>

class MyBlock : public CiraBlockRuntime::IBlock {
public:
    bool Initialize(const BlockConfig& config) override;
    bool Execute() override;
    void Shutdown() override;

    std::string GetBlockId() const override { return "my-block"; }
    std::string GetBlockVersion() const override { return "1.0.0"; }
    std::string GetBlockType() const override { return "processing"; }

    // ... implement pin and I/O methods
};

// Export factory functions
extern "C" {
    IBlock* CreateBlock() { return new MyBlock(); }
    void DestroyBlock(IBlock* block) { delete block; }
}
```

### Building a Block

```cmake
# CMakeLists.txt for a block
add_library(my-block-v1.0.0 SHARED my_block.cpp)
target_include_directories(my-block-v1.0.0 PRIVATE
    /usr/local/include/cira-block-runtime
)
install(TARGETS my-block-v1.0.0
    LIBRARY DESTINATION /usr/local/lib/cira/blocks/
)
```

## Directory Structure

```
cira-block-runtime/
├── include/              # Public headers
│   ├── block_interface.hpp
│   ├── data_types.hpp
│   ├── manifest_parser.hpp
│   ├── block_loader.hpp
│   └── block_executor.hpp
├── src/                  # Runtime implementation
│   ├── main.cpp
│   ├── manifest_parser.cpp
│   ├── block_loader.cpp
│   └── block_executor.cpp
├── blocks/               # Example block implementations
│   ├── sensors/
│   ├── processing/
│   ├── models/
│   └── outputs/
├── platforms/            # Platform-specific code
│   ├── jetson_nano/
│   └── uno_q/
└── tests/                # Unit tests
```

## Deployment from Pipeline Builder

The Pipeline Builder can deploy to devices using Block Runtime mode:

1. Select **Deploy > Deploy to Device**
2. Choose **Block Runtime (Development)** mode
3. Pipeline Builder will:
   - Generate `block_manifest.json`
   - Transfer manifest to device via SSH
   - Verify blocks exist on device
   - Start `cira-block-runtime` with manifest

## Supported Platforms

### Jetson Nano
- **OS**: Ubuntu 20.04 ARM64
- **Blocks**: Single-process, all blocks in one runtime
- **Installation**: `sudo apt install cira-block-runtime`

### Arduino UNO Q
- **OS**: Debian Linux (MPU) + Zephyr OS (MCU)
- **Blocks**: Hybrid dual-core architecture
  - MPU blocks: AI, networking (`.so` libraries)
  - MCU blocks: Sensors, GPIO (Zephyr drivers)
- **IPC**: Message passing between cores

## Troubleshooting

### Block Not Found
```
ERROR: Failed to load library: /usr/local/lib/cira/blocks/my-block-v1.0.0.so
```
**Solution**: Install the missing block or check `--block-path`

### Symbol Not Found
```
ERROR: Failed to find CreateBlock: undefined symbol
```
**Solution**: Ensure block exports `CreateBlock` and `DestroyBlock` with `extern "C"`

### Cycle Detected
```
ERROR: Cycle detected in execution graph
```
**Solution**: Check manifest for circular connections between nodes

## License

Copyright (c) 2025 CiRA Project

## Contributing

Block contributions welcome! See `blocks/` for examples.
